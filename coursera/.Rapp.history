logtime.LA <- lig(time.LA)
logtime.LA <- log(time.LA)
res.surv.M <- survfit(Surv(pfs.month) ~ pancreatic$stage, #
                      subset=(pancreatic$stage == 'M'))
time.M <- res.surv.M$time
surv.M <- res.surv.M$surv
c.log.log.M <- log(-log(surv.M))
logtime.M <- log(time.M)
plot(c.log.log.LA ~ logtime.LA, type='s', col=4)
lines(c.log.log.M ~ logtime.M, col=2, type='s')
plot(c.log.log.LA ~ logtime.LA, type='s', col=4, ylim=c(-2, 1))#
lines(c.log.log.M ~ logtime.M, col=2, type='s')
plot(c.log.log.LA ~ logtime.LA, type='s', col=4, ylim=c(-2, 1.5))#
lines(c.log.log.M ~ logtime.M, col=2, type='s')
legend('bottomleft', legend=c('Locally Advanced', 'Metastatic'), col=c(4, 2))
legend(#
  'bottomright', legend=c('Locally Advanced', 'Metastatic'), col=c(4, 2), lty=1)
?dist
?plot.hclust
setwd('~/Learning/R/RLearning/Multivariate')#
#
library(lattice)#
library(MVA)#
library(mvtnorm)
library(mclust)
thomsonprop
demo('Ch-CA')
cnt <- c(#
  "Iceland", "Norway", "Sweden", "Finland", "Denmark", "UK", "Eire",#
  "Germany", "Netherlands", "Belgium", "Switzerland", "France", "Spain",#
  "Portugal", "Italy", "Greece", "Yugoslavia", "Albania", "Bulgaria", "Romania",#
  "Hungary", "Czechia", "Slovakia", "Poland", "CIS", "Lithuania", "Latvia",#
  "Estonia")
thomson <- expand.grid(answer=factor(c("no", "yes")),#
                       question=factor(paste("Q", 1:6, sep="")),#
                       country=factor(cnt, levels=cnt))
thomson$Freq <- c(#
  0, 5, 0, 5, 0, 4, 0, 5, 0, 5, 0, 5, 1, 6, 1, 5, 0, 6, 0, 5, 0, 4, 1, 4, 0, 11, #
  4, 7, 0, 7, 0, 11, 5, 5, 3, 6, 0, 6, 2, 4, 0, 6, 0, 6, 1, 5, 2, 4, 1, 12, 4, #
  9, 0, 12, 3, 9, 7, 4, 6, 7, 7, 12, 2, 16, 0, 20, 1, 19, 9, 10, 0, 17, 0, 1, 1, #
  2, 0, 3, 2, 0, 2, 0, 0, 3, 0, 14, 0, 13, 0, 13, 2, 12, 11, 2, 1, 13, 0, 8, 0, #
  8, 0, 8, 1, 7, 2, 5, 1, 7, 2, 0, 0, 2, 0, 2, 1, 1, 2, 0, 0, 2, 0, 5, 0, 5, 0,#
  4, 2, 2, 5, 0, 0, 4, 7, 3, 1, 7, 3, 5, 8, 2, 10, 0, 1, 7, 11, 1, 0, 12, 2, 8, #
  5, 6, 11, 0, 0, 11, 5, 1, 0, 6, 2, 4, 3, 3, 6, 0, 0, 6, 8, 7, 0, 15, 1, 13, 9, #
  6, 13, 2, 0, 15, 7, 1, 0, 8, 3, 5, 7, 1, 8, 0, 0, 7, 11, 4, 0, 15, 7, 8, 11, #
  4, 15, 0, 0, 14, 3, 2, 2, 3, 3, 2, 3, 2, 3, 3, 2, 3, 3, 0, 0, 3, 2, 1, 3, 0, #
  3, 0, 0, 3, 7, 0, 0, 6, 6, 1, 6, 1, 6, 1, 0, 7, 4, 1, 0, 5, 1, 4, 5, 0, 5, 0, #
  0, 5, 18, 2, 0, 20, 17, 3, 20, 0, 20, 0, 0, 20, 13, 0, 1, 14, 14, 0, 16, 0, #
  13, 0, 15, 0, 18, 0, 0, 19, 13, 5, 17, 2, 17, 0, 0, 19, 7, 0, 1, 6, 5, 2, 7, #
  0, 7, 0, 1, 6, 8, 0, 0, 8, 8, 0, 8, 0, 8, 0, 0, 8, 5, 0, 0, 5, 5, 0, 5, 0, 5, #
  0, 0, 5,2, 2, 0, 3, 0, 3, 3, 0, 3, 0, 0, 3)
head(thomson)
ttab <- xtabs(Freq ~ country + answer + question, data=thomson)
ttab
thomsonprop <- prop.table(ttab, c(1,3))[,"yes",]
for (q in 1:6) {   #
  tmp <- ttab[,,q]#
  xstart <- (q - 1) * 22 + 1#
  y <- -rep(1:nrow(tmp), rowSums(tmp))#
  x <- xstart + unlist(sapply(rowSums(tmp), function(i) 1:i))#
  pch <- unlist(apply(tmp, 1, function(x) c(rep(19, x[2]), rep(1, x[1]))))#
  points(x, y, pch = pch)#
}
axis(2, #
     at=-(1:nlevels(thomson$country)), #
     labels=levels(thomson$country),#
     las=2, #
     tick=F, #
     line=0)
mtext(text=paste("Question", 1:6), 3, at=22 * (0:5), adj=0)
(mc <- Mclust(thomsonprop))
plot(mc, thomsonprop, what="BIC", col="black")
cl <- mc$classification
nm <- unlist(sapply(1:3, function(i) names(cl[cl == i])))
ttab <- ttab[nm,,]
plot(1:(22 * 6), #
     rep(-1, 22 * 6), #
     ylim=c(-nlevels(thomson$country), -1), #
     type="n",#
     axes=F, #
     xlab="", #
     ylab="")
library(flexclust)
for (q in 1:6) {   #
  tmp <- ttab[,,q]#
  xstart <- (q - 1) * 22 + 1#
  y <- -rep(1:nrow(tmp), rowSums(tmp))#
  x <- xstart + unlist(sapply(rowSums(tmp), function(i) 1:i))#
  pch <- unlist(apply(tmp, 1, function(x) c(rep(19, x[2]), rep(1, x[1]))))#
  points(x, y, pch=pch)#
}
mtext(text=paste("Question", 1:6), 3, at=22 * (0:5), adj=0)#
abline(h=-cumsum(table(cl))[-3] - 0.5, col="grey")#
text(-c(0.75, 0.75, 0.75), -cumsum(table(cl)) + table(cl)/2,#
     label=paste("Cluster", 1:3), #
     srt=90, #
     pos=1)
mt1.G1 <- minimalTriang(G1)
G2 <- ug(~a:b:e:f + b:c:d:e)
plot(G2)
par(mfrow=c(2, 2))
plot(G1, sub='G1')
plot(G1, main='G1')
par(mfrow=c(2, 2))#
plot(G1, main='G1')
plot(mt1.G1)
plot(G2, main='G2')
mt2.G1 <- minimalTriang(G1, TuG=G2)
mt2.G1 <- minimalTriang(G1, tobject=G2)
plot(mt2.G1)
G1 <- ug(~a:b + b:c + c:d + d:e + e:f + a:f + b:e)
par(mfrow=c(1, 3))
G1.rip <- mpd(G1)
G1.rip
plot(G1)
plot(subGraph(G1.rip$clique[[1]], G1))
plot(subGraph(G1.rip$clique[[2]], g1))
plot(subGraph(G1.rip$clique[[2]], G1))
dag0 <- dag(~a + b|a + c|a*b + d|c*e + e|a + g|f)
par(mfrow=c(1, 1)
)
plot(dag0)
adj(moralize(dag0), e)
adj(moralize(dag0), 'e')
plot(dag0, attrs=list(node=list(fillcolor='lightgrey', fontcolor='red')))
ug2 <- ug(~a:b:c + c:d + d:e + a:e)
ug3 <- triangulate(ug2)
plot(ug3)
egdeNames(ug3)
edgeNames(ug3)
ng3 <- agopen(ug3, name='ug3', layoutType='fdp')
ng4 <- ng3
AgEdge(ng4) <- AgEdge(ng4)[-3]
plont(ng3)
plot(ng3)
plot(ng4)
plot(ng3)#
plot(ng4)
m.days <- 31#
matt.proj   <- 3013290#
collin.proj <- 3225763#
damian.proj <- 3161896#
start.day <- 3 #
holiday.idx <- F #
#
x <- c(#
                        143735, 182843, 132038, #
  30222, 34895, 139256, 123720, 148995, 134032, 82227,#
  40458, 46326, 101267)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)
m.days <- 31#
matt.proj   <- 3013290#
collin.proj <- 3225763#
damian.proj <- 3161896#
start.day <- 3 #
holiday.idx <- F #
#
x <- c(#
                        143735, 182843, 132038, #
  30222, 34895, 139256, 123720, 148995, 134032, 82227,#
  40458, 46326, 101267)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)#
iters <- 500#
days.left <- m.days - length(x)#
preds <- numeric(m.days)#
preds[1:length(x)] <- x#
weekday.sample <- x[weekdays < 6]#
weekday.sample <- weekday.sample[!is.na(weekday.sample)]#
if (length(weekday.sample) == 1) {#
  weekday.sample <- weekday.sample * c(0.9, 1, 1.1)#
}#
weekend.sample <- x[weekdays > 5]#
weekend.sample <- weekend.sample[!is.na(weekend.sample)]#
pred.m <- matrix(nrow=m.days, ncol=iters)#
for (i in 1:iters) {#
  for (d in (length(x) + 1):m.days) {#
    day <- weekdays[d]#
    if (day < 6) {#
      samp <- sample(weekday.sample, 1) + rnorm(1, 0, sd(weekday.sample))#
    } else {#
      if (length(weekend.sample)) {#
        samp <- sample(weekend.sample, 1) + rnorm(1, 0, sd(weekend.sample))#
      } else { #
        samp <- 30000	#
      }#
    }#
    preds[d] <- samp#
  }#
  pred.m[, i] <- cumsum(preds)#
  lines(preds, col=rgb(0, 0, 0, 0.01))#
  lines(cumsum(preds), col=rgb(1, 0, 0, 0.05))#
}#
x.qs <- apply(pred.m, 1, quantile, prob=c(0.025, 0.5, 0.975))#
x.mean <- apply(pred.m, 1, mean)#
upper.x <- x.qs[3, ]#
best.x  <- x.qs[2, ]#
lower.x <- x.qs[1, ]#
#
lines(upper.x, lty=4, col=4)#
lines(lower.x, lty=4, col=4)#
lines(best.x, col=4, lwd=3)#
#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)#
legend('topleft', #
       lty=c(1, 2, 3, 1, 1, 4),#
       lwd=c(1, 1, 1, 1, 3, 1),#
       col=c(6, 6, 6, 1, 4, 4), #
       legend=c('Matt', 'Collin', 'Damian', 'Daily Revenue', #
                'Cumulative Revenue', '95% CI'), #
       bg=rgb(1, 1, 1, 0.75))#
best.x[m.days]
m.days <- 31#
matt.proj   <- 3013290#
collin.proj <- 3225763#
damian.proj <- 3161896#
start.day <- 3 #
holiday.idx <- F #
#
x <- c(#
                        143735, 182843, 132038, #
  30222, 34895, 139256, 123720, 148995, 134032, 82227,#
  40458, 46242, 101032, 112187)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)
rm(list=ls())#
setwd('~/Learning/R/RLearning/QuantileRegression')#
#
library(nor1mix)#
library(quantreg)#
data(barro)
x <- rnorm(50)
y <- matrix(rnorm(100), 50)
fit <- rq(y ~ x)
y <- rnorm(50)#
x <- matrix(rnorm(100), 50)#
fit <- rq(y ~ tau=0.4)
fit <- rq(y ~ x, tau=0.4)
summary(fit, se='boot', bsmethod='xy')
summary(fit, se='boot', bsmethod='pwy')
summary(fit, se='boot', bsmethod='mcmb')
data(bosco)
data(Bosco)
sample(27)
m.days <- 31#
matt.proj   <- 3013290#
collin.proj <- 3225763#
damian.proj <- 3161896#
start.day <- 3 #
holiday.idx <- F #
#
x <- c(#
                        143735, 182843, 132038, #
  30222, 34895, 139256, 123720, 148995, 134032, 82227,#
  40458, 46242, 101032, 112103, 113430)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)
nans <- c('0035000001goRnL')
setwd('~/Learning/R/RLearning/Multivariate')#
#
library(flexclust)#
library(lattice)#
library(mclust)#
library(MVA)#
library(mvtnorm)
rm(list=ls())#
setwd('~/Learning/R/RLearning/GraphicalModels')#
library(ggm)#
library(gRbase)#
library(igraph)#
library(lcd)#
library(RBGL)#
library(Rgraphviz)
ug4 <- graph.formula(a -- b:c, c -- b:d, e -- a:d)
ug4
plot(ug4, layout=layout.graphopt)
ug4.2 <- graph.empty(n=5, directed=F)
V(ug4.2)$name <- V(ug4.2)$label <- letters[1:5]
ug4.2 <- add.edges(ug4.2, c(0,1, 0,2, 0,4, 1,2, 2,3, 3,4))
ug4$layout <- layout.graphopt(ug4)
V(ug4)$label <- V(ug4)$name
V(ug4)$color <- 'red'
V(ug4)[1]$color <- 'blue'
v(ug4)$size <- 40
V(ug4)$size <- 40
V(ug4)$label.cex <- 3
plot(ug4)
ug5 <- set.vertex.attribute(ug4, 'discrete', value=c(T, T, F, F, T))
V(ug4)[discrete]$color <- 'green'
V(ug5)[discrete]$color <- 'green'
v(ug5)[!discrete]$color <- 'yellow'
V(ug5)[!discrete]$color <- 'yellow'
xy <- tkplot.getcoords(2)
laout.spring(ug4)
layout.spring(ug4)
ug5 <- ug(~A*B*C + B*C*D + D*E, result='igraph')
ug6 <- ug(~A*B + B*C + C*D + D*E, result='igraph')
ug6$layout <- ug5$layout <- layout.spring(ug5)
V(ug5)$size <- V(ug6)$size <- 50
V(ug5)$label.cex <- V(ug6)$label.cex <- 3
par(mfrow=c(1, 2))
plot(ug5)
plot(ug6)
em1 <- c(0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0)
dim(em1) <- c(4, 4)
iG <- graph.adjacency(em1)
V(iG)$shape <- c('circle', 'square', 'circle', 'square')
V(iG)$shape <- c('circle', 'square')
V(iG)$color <- c('red', 'green')
V(iG)$label <- c('A', 'B', 'C','D')
V(iG)$arrow.mode <- c(2, 0)[1 + is.mutual(iG)]
E(iG)$arrow.mode <- c(2, 0)[1 + is.mutual(iG)]
E(iG)$color <- c('black', 'darkgrey')
E(iG)curved <- c(T, F)
E(iG)$curved <- c(T, F)
iG$layout <- layout.graphopt(iG)
plot(iG)
m.days <- 31#
matt.proj   <- 3013290#
collin.proj <- 3225763#
damian.proj <- 3161896#
start.day <- 3 #
holiday.idx <- F #
#
x <- c(#
                        143735, 182843, 132038, #
  30222, 34895, 139256, 123720, 148995, 134032, 82227,#
  40458, 46242, 101032, 112103, 113346, 169834)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)
m.days <- 31#
matt.proj   <- 3013290#
collin.proj <- 3225763#
damian.proj <- 3161896#
start.day <- 3 #
holiday.idx <- F #
#
x <- c(#
                        143735, 182843, 132038, #
  30222, 34895, 139256, 123720, 148995, 134032,  82227,#
  40458, 46242, 101032, 112103, 113346, 169834, 108185,#
  28661, 27095)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)
library(sna)
aG <- as(graph.famous('Meredith'), 'matrix')
gplot3d(aG)
V <- c('a', 'b', 'c', 'd')
edL <- vector('list', length=4)
names(edL) <- V
for (i in 1:4) {#
  edL[[i]] <- list(edges=5 - i)#
}
gR <- new('graphNEL', nodes=V, edgeL=edL)
plot(gR)
args(querygraph)
ug_NEL <- ug(~a:b + b:c:d + e)
plot(ug_NEL)
separates('a', 'd', c('b', 'c'), ug_NEL)
ug_igraph <- as(ug_NEL, 'igraph')
querygraph(ug_igraph, 'separates', 'a', 'd', c('b', 'c'))
library(ggm)#
library(gRbase)#
library(igraph)#
library(lcd)#
library(RBGL)#
library(Rgraphviz)#
library(sna)
data(reinis)
str(reinis)
head(reinis)
data(mildew)
str(mildew)
data(dumping)
str(dumping)
data(lizardRAW)
head(lizardRaw)
head(lizardRAW)
data(lizard)
str(lizard)
lizare
lizard
data(lizardAGG)
lizardAGG
30 * 221
m.days <- 30#
matt.proj   <- 3197961#
collin.proj <- 3432777#
damian.proj <- 3319632#
start.day <- 6 #
holiday.idx <- 3 #
#
x <- c(#
  31373, 35463,  35044, 109000)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)
rm(list=ls())#
setwd('~/Learning/R/RLearning/QuantileRegression')#
#
library(nor1mix)#
library(quantreg)#
library(survival)
library(zoo)
82641 * 128
library(datasets)
data(UKDriverDeaths)
uk <- log10(UKDriverDeaths)
dfm <- dynrq(uk ~ L(uk, 1) + L(uk, 12))
dfm
dfm3 <- dynrq(uk ~ L(uk, 1) + L(uk, 12), tau=1:3 / 4)
dfm1 <- dynrq(uk ~ L(uk, 1) + L(uk, 12), start=c(1975, 1), end=c(1982, 12))
dfm0 <- update(dfm1, . ~ . - L(uk, 12))
tuk1 <- anova(dfm0, dfm1)
tuk1
dfm1 <- dynrq(uk ~ 1, start=c(1975, 1), end=c(1982, 12))
dfm2 <- dynrq(uk ~ season(uk), start=c(1975, 1), end=c(1982, 12))
(tuk2 <- anova(dfm1, dfm2))
summary(dfm2)
dfm3 <- dynrq(uk ~ L(uk, c(1, 11, 12)), start=c(1975, 1), end=c(1982, 12))
anova(dfm1, dfm3)
summary(dfm3)
data(AirPassengers)
ap <- log(AirPassengers)
fm <- dynrq(ap ~ trend(ap) + season(ap), tau=1:4 / 5)
(sfm <- summary(fm))
plot(sfm)
m.days <- 30#
matt.proj   <- 3197961#
collin.proj <- 3432777#
damian.proj <- 3319632#
start.day <- 6 #
holiday.idx <- 3 #
#
x <- c(#
  31373, 35379,  35044, 112748, 122821)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)
iters <- 500#
days.left <- m.days - length(x)#
preds <- numeric(m.days)#
preds[1:length(x)] <- x#
weekday.sample <- x[weekdays < 6]#
weekday.sample <- weekday.sample[!is.na(weekday.sample)]#
if (length(weekday.sample) == 1) {#
  weekday.sample <- weekday.sample * c(0.9, 1, 1.1)#
}#
weekend.sample <- x[weekdays > 5]#
weekend.sample <- weekend.sample[!is.na(weekend.sample)]#
pred.m <- matrix(nrow=m.days, ncol=iters)#
for (i in 1:iters) {#
  for (d in (length(x) + 1):m.days) {#
    day <- weekdays[d]#
    if (day < 6) {#
      samp <- sample(weekday.sample, 1) + rnorm(1, 0, sd(weekday.sample))#
    } else {#
      if (length(weekend.sample)) {#
        samp <- sample(weekend.sample, 1) + rnorm(1, 0, sd(weekend.sample))#
      } else { #
        samp <- 30000	#
      }#
    }#
    preds[d] <- samp#
  }#
  pred.m[, i] <- cumsum(preds)#
  lines(preds, col=rgb(0, 0, 0, 0.01))#
  lines(cumsum(preds), col=rgb(1, 0, 0, 0.05))#
}#
x.qs <- apply(pred.m, 1, quantile, prob=c(0.025, 0.5, 0.975))#
x.mean <- apply(pred.m, 1, mean)#
upper.x <- x.qs[3, ]#
best.x  <- x.qs[2, ]#
lower.x <- x.qs[1, ]#
#
lines(upper.x, lty=4, col=4)#
lines(lower.x, lty=4, col=4)#
lines(best.x, col=4, lwd=3)#
#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)#
legend('topleft', #
       lty=c(1, 2, 3, 1, 1, 4),#
       lwd=c(1, 1, 1, 1, 3, 1),#
       col=c(6, 6, 6, 1, 4, 4), #
       legend=c('Matt', 'Collin', 'Damian', 'Daily Revenue', #
                'Cumulative Revenue', '95% CI'), #
       bg=rgb(1, 1, 1, 0.75))#
best.x[m.days]
m.days <- 30#
matt.proj   <- 3197961#
collin.proj <- 3432777#
damian.proj <- 3319632#
start.day <- 6 #
holiday.idx <- 3 #
#
x <- c(#
  31373, 35379,  35044, 112748, 122821)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)#
#
iters <- 500#
days.left <- m.days - length(x)#
preds <- numeric(m.days)#
preds[1:length(x)] <- x#
if (holiday.idx) {#
  x[holiday.idx] <- NA#
}#
weekday.sample <- x[weekdays < 6 & !is.na(x)]
weekday.sample <- weekday.sample[!is.na(weekday.sample)]#
if (length(weekday.sample) == 1) {#
  weekday.sample <- weekday.sample * c(0.9, 1, 1.1)#
}#
weekend.sample <- x[weekdays > 5]#
weekend.sample <- weekend.sample[!is.na(weekend.sample)]#
pred.m <- matrix(nrow=m.days, ncol=iters)#
for (i in 1:iters) {#
  for (d in (length(x) + 1):m.days) {#
    day <- weekdays[d]#
    if (day < 6) {#
      samp <- sample(weekday.sample, 1) + rnorm(1, 0, sd(weekday.sample))#
    } else {#
      if (length(weekend.sample)) {#
        samp <- sample(weekend.sample, 1) + rnorm(1, 0, sd(weekend.sample))#
      } else { #
        samp <- 30000	#
      }#
    }#
    preds[d] <- samp#
  }#
  pred.m[, i] <- cumsum(preds)#
  lines(preds, col=rgb(0, 0, 0, 0.01))#
  lines(cumsum(preds), col=rgb(1, 0, 0, 0.05))#
}#
x.qs <- apply(pred.m, 1, quantile, prob=c(0.025, 0.5, 0.975))#
x.mean <- apply(pred.m, 1, mean)#
upper.x <- x.qs[3, ]#
best.x  <- x.qs[2, ]#
lower.x <- x.qs[1, ]#
#
lines(upper.x, lty=4, col=4)#
lines(lower.x, lty=4, col=4)#
lines(best.x, col=4, lwd=3)#
#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)#
legend('topleft', #
       lty=c(1, 2, 3, 1, 1, 4),#
       lwd=c(1, 1, 1, 1, 3, 1),#
       col=c(6, 6, 6, 1, 4, 4), #
       legend=c('Matt', 'Collin', 'Damian', 'Daily Revenue', #
                'Cumulative Revenue', '95% CI'), #
       bg=rgb(1, 1, 1, 0.75))#
best.x[m.days]
m.days <- 30#
matt.proj   <- 3197961#
collin.proj <- 3432777#
damian.proj <- 3319632#
start.day <- 6 #
holiday.idx <- 3 #
#
x <- c(#
  31373, 35379,  35044, 112748, 122821)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)#
#
iters <- 500#
days.left <- m.days - length(x)#
preds <- numeric(m.days)#
preds[1:length(x)] <- x#
if (holiday.idx) {#
  x[holiday.idx] <- NA#
}#
weekday.sample <- x[weekdays < 6 & !is.na(x)]#
weekday.sample <- weekday.sample[!is.na(weekday.sample)]#
if (length(weekday.sample) == 1) {#
  weekday.sample <- weekday.sample * c(0.9, 1, 1.1)#
}#
weekend.sample <- x[weekdays > 5]#
weekend.sample <- weekend.sample[!is.na(weekend.sample)]#
pred.m <- matrix(nrow=m.days, ncol=iters)#
for (i in 1:iters) {#
  for (d in (length(x) + 1):m.days) {#
    day <- weekdays[d]#
    if (day < 6) {#
      samp <- sample(weekday.sample, 1) + rnorm(1, 0, sd(weekday.sample))#
    } else {#
      if (length(weekend.sample)) {#
        samp <- sample(weekend.sample, 1) + rnorm(1, 0, sd(weekend.sample))#
      } else { #
        samp <- 30000	#
      }#
    }#
    preds[d] <- samp#
  }#
  pred.m[, i] <- cumsum(preds)#
  lines(preds, col=rgb(0, 0, 0, 0.01))#
  lines(cumsum(preds), col=rgb(1, 0, 0, 0.05))#
}#
x.qs <- apply(pred.m, 1, quantile, prob=c(0.025, 0.5, 0.975))#
x.mean <- apply(pred.m, 1, mean)#
upper.x <- x.qs[3, ]#
best.x  <- x.qs[2, ]#
lower.x <- x.qs[1, ]#
#
lines(upper.x, lty=4, col=4)#
lines(lower.x, lty=4, col=4)#
lines(best.x, col=4, lwd=3)#
#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)#
legend('topleft', #
       lty=c(1, 2, 3, 1, 1, 4),#
       lwd=c(1, 1, 1, 1, 3, 1),#
       col=c(6, 6, 6, 1, 4, 4), #
       legend=c('Matt', 'Collin', 'Damian', 'Daily Revenue', #
                'Cumulative Revenue', '95% CI'), #
       bg=rgb(1, 1, 1, 0.75))#
best.x[m.days]
rm(list = ls())#
setwd('~/Learning/R/RLearning/GAM')#
library(gamair)#
data(stomata)
heart <- data.frame(#
  ck = c(20, 60, 100, 140, 180, 220, 260, 300, 340, 380, 420, 460),#
  ha = c( 2, 13,  30,  30,  21,  19,  18,  13,  19,  15,   7,   8),#
  ok = c(88, 26,   8,   5,   0,   1,   1,   1,   1,   0,   0,   0))
p <- heart$ha / (heart$ha + heart$ok)
plot(#
  heart$ck, p, xlab='Creatinine Kinase Level', ylab='Proportion Heart Attacks')
rm(list=ls())#
setwd('~/Learning/R/RLearning/TS/coursera')
sigma <- 4
phi <- NULL
phi <- numeric(2)
phi <- c(1/3, 2/3)
n <- 1000
phi <- c(1/3, 1/2)
ar.process <- arima.sim(n, model=list(ar=phi), sd=sigma)
ar.process[1:5]
r <- acf(ar.process, plot=F)$acf[2:3]
r
R <- matrix(1, 2, 2)
R[1, 2] <- r[1]
r[2, 1] <- r[1]
R[2, 1] <- r[1]
R
b <- matrix(r, 2, 1)
b
phi.hat <- matrix(c(solve(R, b)[1, 1], solve(R, b)[2, 1]), 2, 1)
phi.hat
c0 <- acf(ar.process, type='covariance', plot=F)$acf[1]
var.hat <- c0 * (1 - sum(ph.hat * r))
var.hat <- c0 * (1 - sum(phi.hat * r))
var.hat
par(mfrow=c(3, 1))
plot(ar.process, main='Simulated AR(2)')
acf(ar.process, main='ACF')
pacf(ar.process, main='PACF')
plot(11965, 8907, 9304, 8638, 9001, 8411, 8735, 8200, type='l')
plot(c(11965, 8907, 9304, 8638, 9001, 8411, 8735, 8200), type='l')
m.days <- 30#
matt.proj   <- 3197961#
collin.proj <- 3432777#
damian.proj <- 3319632#
start.day <- 6 #
holiday.idx <- 3 #
#
x <- c(#
  31373, 35379,  35044, 112748, 122821,  92438)#
weekdays <- numeric(m.days)#
weekdays[1] <- start.day#
for (i in 2:m.days) {#
  weekdays[i] <- weekdays[i - 1] %% 7 + 1#
}#
if (holiday.idx) {#
  for (i in holiday.idx) {#
    weekdays[i] <- 7 #
  }#
}#
plot(x, #
     ylim=c(min(x), #
            max(1.2 * m.days * max(cumsum(x)) / length(x), #
                matt.proj, #
                collin.proj, #
                damian.proj)), #
     type='l', #
     main='Monthly Revenue',#
     xlab='Days into month',#
     ylab='$',#
     xlim=c(1, m.days))#
lines(cumsum(x), col=2)#
abline(h=0, lty=4)#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)
iters <- 500#
days.left <- m.days - length(x)#
preds <- numeric(m.days)#
preds[1:length(x)] <- x#
if (holiday.idx) {#
  x[holiday.idx] <- NA#
}#
weekday.sample <- x[weekdays < 6 & !is.na(x)]#
weekday.sample <- weekday.sample[!is.na(weekday.sample)]#
if (length(weekday.sample) == 1) {#
  weekday.sample <- weekday.sample * c(0.9, 1, 1.1)#
}#
weekend.sample <- x[weekdays > 5]#
weekend.sample <- weekend.sample[!is.na(weekend.sample)]#
pred.m <- matrix(nrow=m.days, ncol=iters)#
for (i in 1:iters) {#
  for (d in (length(x) + 1):m.days) {#
    day <- weekdays[d]#
    if (day < 6) {#
      samp <- sample(weekday.sample, 1) + rnorm(1, 0, sd(weekday.sample))#
    } else {#
      if (length(weekend.sample)) {#
        samp <- sample(weekend.sample, 1) + rnorm(1, 0, sd(weekend.sample))#
      } else { #
        samp <- 30000	#
      }#
    }#
    preds[d] <- samp#
  }#
  pred.m[, i] <- cumsum(preds)#
  lines(preds, col=rgb(0, 0, 0, 0.01))#
  lines(cumsum(preds), col=rgb(1, 0, 0, 0.05))#
}#
x.qs <- apply(pred.m, 1, quantile, prob=c(0.025, 0.5, 0.975))#
x.mean <- apply(pred.m, 1, mean)#
upper.x <- x.qs[3, ]#
best.x  <- x.qs[2, ]#
lower.x <- x.qs[1, ]#
#
lines(upper.x, lty=4, col=4)#
lines(lower.x, lty=4, col=4)#
lines(best.x, col=4, lwd=3)#
#
abline(h=matt.proj,   col=6, lty=1)#
abline(h=collin.proj, col=6, lty=2)#
abline(h=damian.proj, col=6, lty=3)#
legend('topleft', #
       lty=c(1, 2, 3, 1, 1, 4),#
       lwd=c(1, 1, 1, 1, 3, 1),#
       col=c(6, 6, 6, 1, 4, 4), #
       legend=c('Matt', 'Collin', 'Damian', 'Daily Revenue', #
                'Cumulative Revenue', '95% CI'), #
       bg=rgb(1, 1, 1, 0.75))#
best.x[m.days]
rm(list = ls())#
library(tseries)#
#
START_YEAR <- 2007#
END_YEAR <- 2018#
START_MONTH <- 1#
FREQ <- 12#
N_TEST <- 12#
#
load.data <- function(path, log.data) {#
  dat <- read.csv(path)#
  dat$month <- as.Date(dat$month, format='%m/%d/%y')#
  names(dat) <- c('month', 'rev')#
  if (log.data) {#
  	cat('Converting values to log(values)\n')#
  	dat$rev <- log(dat$rev)#
  }#
  cat('DF Head:\n')#
  print(head(dat))#
  cat('DF Tail:\n')#
  print(tail(dat))#
#
  cat('\nrows:', nrow(dat)) #
  dat <- ts(dat$rev, start=c(START_YEAR, START_MONTH), freq=FREQ)#
  dat#
}#
#
get.rmse <- function(preds, targets) {#
  sqrt(mean((preds - targets)^2))#
}#
#
add.years.months <- function(init, add) {#
  new <- init + add#
  year <- new[1]#
  month <- new[2]#
  if (month > 12) {#
  	quotient <- trunc(month / 12)#
  	remainder <- month %% 12#
  	new <- c(year + quotient, remainder)#
  }#
  new#
}#
#
periods.to.years.months <- function(n.periods) {#
  years <- trunc(n.periods / 12)#
  months <- n.periods %% 12#
  c(years, months)  #
}#
#
slice.ts <- function(#
  t.series, start.idx, end.idx, ts.start=c(START_YEAR, START_MONTH)) {#
  start.date <- periods.to.years.months(start.idx)#
  start.date <- add.years.months(c(START_YEAR, START_MONTH), start.date)#
  start.date <- add.years.months(start.date, c(0, -1))#
  end.date   <- periods.to.years.months(end.idx)#
  end.date   <- add.years.months(c(START_YEAR, START_MONTH), end.date)#
  end.date   <- add.years.months(end.date, c(0, -1))#
  ts(t.series[start.idx:end.idx], start=start.date, end=end.date, freq=FREQ)#
}#
#
split.train.test <- function(dat, n.test=N_TEST) {#
  n <- length(dat)#
  n.train <- n - n.test#
  train <- slice.ts(dat, 1, n.train)#
  test  <- slice.ts(dat, n.train + 1, n)#
  list(test=test, train=train)#
}#
#
update.best <- function(best, rmse, mod.name) {#
  if (rmse < best$rmse) { #
    best$rmse <- rmse#
    best$mod <- mod.name#
  }#
#
  best#
}#
#
plot.mod <- function(mod.fitted, mod.preds, mod.name) {#
  plot(mod.fitted, #
       lwd=2,#
       xlim=c(START_YEAR, END_YEAR + 1), #
       ylim=range(train, test),#
       main=mod.name)#
  lines(test, col='grey', lwd=2)#
  lines(mod.preds, col=2, lwd=2)#
  legend('topleft', #
         lwd=c(1, 2, 2), #
         col=c('black', 'grey', 'red'), #
         legend=c('train', 'test', 'model'))#
}#
#
find.best.hw <- function(train.set, iters=10000) {#
  best.HW.sse <- Inf#
  best.HW.params <- c(0, 0)#
  sses <- rep(NA, iters)#
#
  for (i in 1:iters) {#
  	if (i %% 100 == 0) { #
  	  plot(sses, #
  	       xlab='Iterations', #
  	       ylab='SSE of best model found', #
  	       type='l', #
  	       col=2)#
  	}#
#
    beta <- runif(1)#
    gamma <- runif(1)#
    hw.test.mod <- HoltWinters(#
      train.set, beta=beta, gamma=gamma, seasonal='additive')#
#
    if (hw.test.mod$SSE < best.HW.sse) {#
      best.HW.params <- c(beta, gamma)#
      best.HW.sse <- hw.test.mod$SSE#
      best.HW.mod <- hw.test.mod#
    }#
    sses[i] <- best.HW.sse#
  }#
#
  plot(sses, xlab='Iterations', ylab='SSE of best model found', type='l', col=2)#
  best.HW.mod#
}#
#
get.best.arima <- function(x.ts, #
                           start.ord=c(0, 0, 0, 0, 0, 0), #
                           max.ord=c(1, 1, 1, 1, 1, 1), #
                           best.aic=Inf) {#
  n <- length(x.ts)#
  for (p in start.ord[1]:max.ord[1]) {#
    for (d in start.ord[2]:max.ord[2]) {#
      for (q in start.ord[3]:max.ord[3]) {#
        for (P in start.ord[4]:max.ord[4]) {#
          for (D in start.ord[5]:max.ord[5]) {#
            for (Q in start.ord[6]:max.ord[6]) {	#
              fit <- arima(x.ts, #
                           order=c(p, d, q), #
                           seas=list(order=c(P, D, Q), frequency(x.ts)), #
                           method='CSS')#
              fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)#
              if (fit.aic < best.aic) {#
              	best.aic <- fit.aic#
              	best.fit <- fit#
              	best.params <- c(p, d, q, P, D, Q)#
              	cat('\n\nNew Best ARIMA found with parameters', #
              	    p, d, q, P, D, Q)#
              	cat('\nAIC:', fit.aic)#
              }#
            }#
          }#
        }#
        cat('\nFinished testing:', p, d, q, P, D, Q)#
      }#
    }#
  }#
  cat('\n')#
  list(aic=best.aic, mod=best.fit, params=best.params)#
}#
#
find.best.weighted.combo <- function(preds1, preds2, best.rmse, iters=1000) {#
  rmses <- rep(NA, iters + 1)#
  rmses[1] <- best.rmse#
  best.weights <- c(1, 0) #
  for (i in 2:(iters + 1)) {#
    w1 <- runif(1)#
    w2 <- 1 - w1#
    weighted.preds <- w1 * preds1 + w2 * preds2#
    rmse <- get.rmse(weighted.preds, test)#
    if (rmse < best.rmse) {#
      best.rmse <- rmse#
      best.weights <- c(w1, w2)#
    }#
    rmses[i] <- best.rmse#
    plot(rmses, xlab='iterations', ylab='Best RMSE', type='l', col=2)#
  }#
  best.weights#
}
dat <- load.data('~/repos/scripts-analytics/revenue/2018/revTS.csv', log.data=T)#
split <- split.train.test(dat)#
train <- split$train#
test  <- split$test
plot(train, xlim=c(2007, 2019), ylim=range(c(train, test)))#
lines(test, col=2)#
abline(v=2018, col=4)
baseline.hw.mod <- HoltWinters(train, beta=0, gamma=0, seasonal='additive')#
baseline.hw.pred <- predict(baseline.hw.mod, n.ahead=N_TEST)#
#
plot.mod(baseline.hw.mod, baseline.hw.pred, 'HW Baseline')#
(baseline.hw.rmse <- get.rmse(baseline.hw.pred, test))#
best <- list(rmse=baseline.hw.rmse, mod=baseline.hw.mod)
best.hw.mod <- find.best.hw(train)#
best.hw.pred <- predict(best.hw.mod, n.ahead=N_TEST)
plot.mod(best.hw.mod, best.hw.pred, 'Best HW')#
(best.hw.rmse <- get.rmse(best.hw.pred, test))
best.arima1 <- get.best.arima(train, max.ord=c(1, 1, 1, 1, 1, 1)) #
best.arima2 <- get.best.arima(train, max.ord=c(2, 2, 2, 2, 2, 2))#
best.arima3 <- get.best.arima(train, max.ord=c(3, 3, 3, 3, 3, 3))#
#
best.arima1.pred <- predict(best.arima1$mod, n.ahead=12)$pred#
(best.arima1.rmse <- get.rmse(best.arima1.pred, test))#
best <- update.best(best, best.arima1.rmse, 'arima1')#
#
best.arima2.pred <- predict(best.arima2$mod, n.ahead=12)$pred#
(best.arima2.rmse <- get.rmse(best.arima2.pred, test))#
best <- update.best(best, best.arima2.rmse, 'arima2')#
#
best.arima3.pred <- predict(best.arima3$mod, n.ahead=12)$pred#
(best.arima3.rmse <- get.rmse(best.arima3.pred, test))#
best <- update.best(best, best.arima3.rmse, 'arima3')
q()
